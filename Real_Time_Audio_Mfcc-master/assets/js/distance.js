function euclideanDistance(a, b) {    sum = 0;    for (var i = 0; i < a.length; i++) {        sum += math.pow(a[i] - b[i], 2)    }    return math.sqrt(sum)}comparedata1 = [];for (var i = 0; i < matrix1[0].length; i++) {    comparedata = [];    for (var j = 0; j < matrix1[0].length; j++) {        comparedata.push(euclideanDistance(matrix1[i], matrix2[j]))    }    comparedata1.push(comparedata)}for (var i = 0; i < 2; i++) {    to = [];    to1 = [];    for (var j = 0; j < 2; j++) {        to.push(euclideanDistance(matrix1[i], matrix2[j]))    }}to1.push(to);for (var i = 0; i < matrix1[0].length; i++) {    norms = math.norm(matrix1[i]) * math.norm(matrix2[i]);    comparedata.push(math.dot(matrix1[i], matrix2[i]) / norms)}comparedata = [];for (var i = 0; i < matrix1.length; i++) {    comparedata.push(euclideanDistance(matrix1[i], matrix2[i]))}math.sum(comparedata)function dataprocess() {    // data normalization    normalized_data = [];    for (var i = 0; i < origin_data.length; i++) {        var data1 = [];        var average = math.mean(origin_data[i]);        for (var j = 0; j < origin_data[0].length; j++) {            data1.push((origin_data[i][j] - average) / math.norm(origin_data[i][j] - average));        }        normalized_data.push(data1);    }    //console.log('cal_ss')    //calculate cos between two mfcc vector->create self similarity matrix    self_similarity_data = [];    for (var i = 0; i < normalized_data.length; i++) {        data2 = [];        matrix1 = [];        matrix2 = [];        for (var j = 0; j < normalized_data.length; j++) {            data2.push((math.dot(normalized_data[i], normalized_data[j]) / 20))        }        self_similarity_data.push(data2);        dataeval.push(data2);        matrix1 = dataeval.slice(0, 600);        matrix2 = dataeval.slice(600, 1200);    }    function euclideanDistance(a, b) {        sum = 0;        for (var i = 0; i < a.length; i++) {            sum += math.pow(a[i] - b[i], 2)        }        return math.sqrt(sum)    }//Create Cross similarity Matrix from 2 SSM data    crossimilarity = [];    cross1 = [];    cross2 = [];    for (var i = 0; i < matrix1.length; i++) {        CSM = [];        for (var j = 0; j < matrix1.length; j++) {            CSM.push(euclideanDistance(matrix1[i], matrix2[j]))        }        crossimilarity.push(CSM.slice());        cross1.push(CSM.slice());        cross2.push(CSM.slice());    }    //  console.log('cal_ss1')    color_data = [];    for (var i = 0; i < crossimilarity[0].length; i++) {        data3 = [];        for (var j = 0; j < crossimilarity[0].length; j++) {            data3.push(d3.rgb(d3.hsl(crossimilarity[i][j] * 257, 1, 0.5)));        }        color_data.push(data3);    }    function drawmatrix() {        var k = color_data.length;        var c = document.getElementById("myCanvas");        var ctx = c.getContext("2d");        var imgData = ctx.createImageData(color_data.length, color_data.length);        //  console.log(imgData);        for (var i = 0; i < k; i++) {            for (var j = 0; j < k; j++) {                var pos = (i * k + j) * 4;                imgData.data[pos + 0] = color_data[i][j].r;                imgData.data[pos + 1] = color_data[i][j].g;                imgData.data[pos + 2] = color_data[i][j].b;                imgData.data[pos + 3] = 255;            }        }        //console.log(imgData.data);        //where to draw the whole image        ctx.putImageData(imgData, count * 620, 0);    }    // console.log('cal_ss2')    drawmatrix(color_data);    origin_data = [];    console.log('drawmatrix')}